import * as THREE from 'three';
import { MathUtils } from '../utils/MathUtils.js';

/**
 * Dinamik kamera kontrol√º ve takip sistemi
 */
export class CameraController {
    constructor(camera, vehicle) {
        this.camera = camera;
        this.vehicle = vehicle;
        
        // Kamera modlarƒ±
        this.modes = {
            THIRD_PERSON: 'third_person',
            FIRST_PERSON: 'first_person',
            CINEMATIC: 'cinematic',
            FREE: 'free'
        };
        
        this.currentMode = this.modes.THIRD_PERSON;
        
        // MANUEL ROTASYON EKLEYELƒ∞M
        this.manualRotation = {
            x: 0,
            y: 0
        };
        
        // Kamera ayarlarƒ±
        this.settings = {
            // Third person ayarlarƒ± - TAKƒ∞P HIZI ARTTIRILDI
            thirdPerson: {
                distance: 10,          // 12'den 10'a d√º≈ü√ºr√ºld√º - daha yakƒ±n takip
                height: 4,             // Y√ºkseklik
                angle: 0.1,            // A≈üaƒüƒ± bakma a√ßƒ±sƒ±
                followSpeed: 18,        // 4'den 8'e √ßƒ±karƒ±ldƒ± - daha hƒ±zlƒ± takip
                rotationSpeed: 6,      // 3'den 6'ya √ßƒ±karƒ±ldƒ± - daha hƒ±zlƒ± d√∂n√º≈ü
                offsetX: 0,            // Yan kayma
                lookAhead: 2           // ƒ∞lerisine bakma
            },
            
            // First person ayarlarƒ±
            firstPerson: {
                height: 0.5,           // Ara√ß i√ßi y√ºkseklik
                offsetZ: 1.0,          // √ñn cam arkasƒ±
                lookAhead: 5           // ƒ∞lerisine bakma
            },
            
            // Cinematic ayarlarƒ±
            cinematic: {
                radius: 15,            // D√∂n√º≈ü yarƒ±√ßapƒ±
                speed: 0.5,            // D√∂n√º≈ü hƒ±zƒ±
                height: 8,             // Y√ºkseklik
                oscillation: 2         // Salƒ±nƒ±m
            }
        };
        
        // Kamera durumu
        this.targetPosition = new THREE.Vector3();
        this.targetLookAt = new THREE.Vector3();
        this.currentLookAt = new THREE.Vector3();
        
        // Smoothing i√ßin
        this.velocity = new THREE.Vector3();
        this.lookAtVelocity = new THREE.Vector3();
        
        // Shake efekti
        this.shakeIntensity = 0;
        this.shakeDuration = 0;
        this.shakeTimer = 0;
        
        // Cinematic mod i√ßin
        this.cinematicTime = 0;
        this.cinematicCenter = new THREE.Vector3();
        
        // Kullanƒ±cƒ± kontrol√º (mouse ile kamera d√∂n√º≈ü√º)
        this.mouseControl = {
            enabled: false,
            sensitivity: 0.002,
            pitch: 0,
            yaw: 0,
            maxPitch: Math.PI / 3
        };
        
        this.init();
        console.log('üì∑ Kamera kontrolc√ºs√º ba≈ülatƒ±ldƒ±');
    }
    
    /**
     * Kamera kontrolc√ºs√ºn√º ba≈ülat
     */
    init() {
        // Ba≈ülangƒ±√ß pozisyonu
        this.updateTargetPositions();
        this.camera.position.copy(this.targetPosition);
        this.camera.lookAt(this.targetLookAt);
        this.currentLookAt.copy(this.targetLookAt);
        
        this.setupMouseControls();
    }
    
    /**
     * Mouse kontrollerini ayarla
     */
    setupMouseControls() {
        this.mouseState = {
            isDown: false,
            lastX: 0,
            lastY: 0,
            sensitivity: 0.002
        };
        
        // Mouse event'leri - SAL TIK SAƒû TIK KARI≈ûIKLIƒûINI √á√ñZELIM
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Sol tƒ±k
                this.mouseState.isDown = true;
                this.mouseState.lastX = event.clientX;
                this.mouseState.lastY = event.clientY;
                event.preventDefault();
            }
            // Saƒü tƒ±k (button === 2) i√ßin hi√ßbir ≈üey yapma
        });
        
        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) { // Sol tƒ±k
                this.mouseState.isDown = false;
            }
            // Saƒü tƒ±k i√ßin hi√ßbir ≈üey yapma
        });
        
        document.addEventListener('mousemove', (event) => {
            if (this.mouseState.isDown && event.buttons === 1) { // Sadece sol tƒ±k s√ºr√ºklemesi
                const deltaX = event.clientX - this.mouseState.lastX;
                const deltaY = event.clientY - this.mouseState.lastY;
                
                this.manualRotation.y -= deltaX * this.mouseState.sensitivity;
                this.manualRotation.x -= deltaY * this.mouseState.sensitivity;
                
                this.manualRotation.x = MathUtils.clamp(this.manualRotation.x, -Math.PI/3, Math.PI/6);
                
                this.mouseState.lastX = event.clientX;
                this.mouseState.lastY = event.clientY;
                
                event.preventDefault();
            }
        });
        
        // SADECE CANVAS ƒ∞√áƒ∞N context menu'yu kapat
        const canvas = document.getElementById('game-canvas');
        if (canvas) {
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
        }
        
        console.log('üñ±Ô∏è Mouse kontrolleri ayarlandƒ±');
    }
    
    /**
     * Kamera modunu deƒüi≈ütir
     */
    switchCameraMode() {
        const modes = Object.values(this.modes);
        const currentIndex = modes.indexOf(this.currentMode);
        const nextIndex = (currentIndex + 1) % modes.length;
        
        this.currentMode = modes[nextIndex];
        
        // Mouse kontrol√ºn√º sƒ±fƒ±rla
        this.mouseControl.pitch = 0;
        this.mouseControl.yaw = 0;
        
        console.log(`üì∑ Kamera modu: ${this.currentMode}`);
    }
    
    /**
     * Kamerayƒ± g√ºncelle
     */
    update(deltaTime) {
        // Hedef pozisyonlarƒ± hesapla
        this.updateTargetPositions();
        
        // Shake efektini uygula
        this.updateShake(deltaTime);
        
        // Kamera pozisyonunu smooth olarak g√ºncelle
        this.smoothCameraMovement(deltaTime);
        
        // Mouse kontrol√ºn√º uygula
        this.applyMouseControls();
    }
    
    /**
     * Hedef pozisyonlarƒ± hesapla (moda g√∂re)
     */
    updateTargetPositions() {
        const vehiclePos = this.vehicle.getPosition();
        const vehicleRot = this.vehicle.getRotation();
        
        switch (this.currentMode) {
            case this.modes.THIRD_PERSON:
                this.calculateThirdPersonTargets(vehiclePos, vehicleRot);
                break;
                
            case this.modes.FIRST_PERSON:
                this.calculateFirstPersonTargets(vehiclePos, vehicleRot);
                break;
                
            case this.modes.CINEMATIC:
                this.calculateCinematicTargets(vehiclePos, vehicleRot);
                break;
        }
    }
    
    /**
     * Third person kamera hedeflerini hesapla - HIZ BAZLI TAKƒ∞P EKLENDƒ∞
     */
    calculateThirdPersonTargets(vehiclePos, vehicleRot) {
        const settings = this.settings.thirdPerson;
        
        // Hƒ±z bazlƒ± uzaklƒ±k ayarlamasƒ± - y√ºksek hƒ±zda daha uzaktan takip
        const speed = this.vehicle.getSpeed();
        const baseDistance = settings.distance;
        const speedBasedDistance = baseDistance + Math.min(speed / 20, 4); // Her 20 km/h i√ßin +1 birim, maksimum +4
        
        // Ara√ß arkasƒ±nda pozisyon - hƒ±z bazlƒ± mesafe
        const distance = speedBasedDistance;
        const height = settings.height;
        
        // Ara√ß y√∂n√ºn√º al
        const vehicleDirection = vehicleRot.y;
        
        // Kamera pozisyonunu ara√ß arkasƒ±nda hesapla
        this.targetPosition.set(
            vehiclePos.x - Math.sin(vehicleDirection) * distance,
            vehiclePos.y + height,
            vehiclePos.z - Math.cos(vehicleDirection) * distance
        );
        
        // Bakƒ±≈ü hedefi - ara√ß + hƒ±z bazlƒ± ileri bakƒ±≈ü
        const speedBasedLookAhead = settings.lookAhead + Math.min(speed / 25, 3); // Hƒ±zda daha ileri bak
        this.targetLookAt.set(
            vehiclePos.x + Math.sin(vehicleDirection) * speedBasedLookAhead,
            vehiclePos.y + 0.5, // Ara√ß seviyesinde bak
            vehiclePos.z + Math.cos(vehicleDirection) * speedBasedLookAhead
        );
        
        // Y√ºksek hƒ±zda kamerayƒ± biraz yukarƒ± √ßek
        if (speed > 40) {
            const speedFactor = Math.min((speed - 40) / 60, 0.8); // Maksimum 0.8 etki
            this.targetPosition.y += speedFactor * 2.0; // Y√ºkseklik artƒ±≈üƒ±
        }
        
        // Angular velocity etkisini minimal tut
        const angularVel = this.vehicle.angularVelocity || 0;
        if (Math.abs(angularVel) > 0.8) { // Sadece √ßok g√º√ßl√º virajlarda
            const lateralOffset = Math.sign(angularVel) * Math.min(Math.abs(angularVel) * 0.2, 0.5);
            this.targetPosition.x += lateralOffset;
        }
    }
    
    /**
     * First person kamera hedeflerini hesapla
     */
    calculateFirstPersonTargets(vehiclePos, vehicleRot) {
        const settings = this.settings.firstPerson;
        
        // Ara√ß i√ßi pozisyon
        const insideOffset = new THREE.Vector3(0, settings.height, settings.offsetZ);
        insideOffset.applyEuler(vehicleRot);
        
        this.targetPosition.copy(vehiclePos).add(insideOffset);
        
        // ƒ∞leri bakƒ±≈ü
        const forwardOffset = new THREE.Vector3(0, 0, settings.lookAhead);
        forwardOffset.applyEuler(vehicleRot);
        this.targetLookAt.copy(vehiclePos).add(forwardOffset);
    }
    
    /**
     * Cinematic kamera hedeflerini hesapla
     */
    calculateCinematicTargets(vehiclePos, vehicleRot) {
        const settings = this.settings.cinematic;
        
        this.cinematicTime += 0.016; // ~60fps
        this.cinematicCenter.copy(vehiclePos);
        
        // Dairesel hareket
        const angle = this.cinematicTime * settings.speed;
        const radius = settings.radius + Math.sin(this.cinematicTime * settings.oscillation) * 3;
        
        this.targetPosition.set(
            this.cinematicCenter.x + Math.cos(angle) * radius,
            this.cinematicCenter.y + settings.height + Math.sin(this.cinematicTime * 0.3) * 2,
            this.cinematicCenter.z + Math.sin(angle) * radius
        );
        
        // Ara√ß merkezi + biraz ileri
        const forwardOffset = new THREE.Vector3(0, 1, 2);
        forwardOffset.applyEuler(vehicleRot);
        this.targetLookAt.copy(vehiclePos).add(forwardOffset);
    }
    
    /**
     * Kamera hareketini smooth yap
     */
    /**
     * Kamera hareketini yumu≈üatma - HIZLI TAKƒ∞P ƒ∞√áƒ∞N D√úZELTƒ∞LDƒ∞
     */
    smoothCameraMovement(deltaTime) {
        // Follow speed'leri yeterince hƒ±zlƒ± yap
        const baseFollowSpeed = this.currentMode === this.modes.THIRD_PERSON ? 
            this.settings.thirdPerson.followSpeed * 0.8 : 8; // 0.4'den 0.8'e √ßƒ±karƒ±ldƒ±
        const baseRotationSpeed = this.currentMode === this.modes.THIRD_PERSON ?
            this.settings.thirdPerson.rotationSpeed * 0.8 : 6; // 0.5'den 0.8'e √ßƒ±karƒ±ldƒ±
        
        // Hƒ±z bazlƒ± ayarlama - d√º≈ü√ºk hƒ±zda daha yava≈ü, y√ºksek hƒ±zda daha hƒ±zlƒ±
        const vehicleSpeed = this.vehicle.getSpeed();
        let speedMultiplier = 1.0; // Varsayƒ±lan √ßarpan
        
        if (vehicleSpeed > 50) {
            // Y√ºksek hƒ±zda daha agresif takip
            speedMultiplier = 1.0 + (vehicleSpeed - 50) / 100; // Maksimum 1.5x hƒ±z
        } else if (vehicleSpeed < 20) {
            // D√º≈ü√ºk hƒ±zda daha yumu≈üak
            speedMultiplier = 0.7;
        }
        
        const followSpeed = baseFollowSpeed * speedMultiplier;
        const rotationSpeed = baseRotationSpeed * speedMultiplier;
        
        // Pozisyon smoothing - daha hƒ±zlƒ± lerp
        const maxPositionLerp = Math.min(deltaTime * followSpeed, 0.20); // 0.08'den 0.20'ye √ßƒ±karƒ±ldƒ±
        this.camera.position.lerp(this.targetPosition, maxPositionLerp);
        
        // LookAt smoothing - daha hƒ±zlƒ±
        const maxRotationLerp = Math.min(deltaTime * rotationSpeed, 0.15); // 0.06'dan 0.15'e √ßƒ±karƒ±ldƒ±
        this.currentLookAt.lerp(this.targetLookAt, maxRotationLerp);
        
        // Kamerayƒ± hedefi takip ettir
        this.camera.lookAt(this.currentLookAt);
    }
    
    /**
     * Mouse kontrollerini uygula
     */
    applyMouseControls() {
        if (this.currentMode === this.modes.THIRD_PERSON && 
            (this.mouseControl.pitch !== 0 || this.mouseControl.yaw !== 0)) {
            
            // Mouse kontrol√º ile kamera pozisyonunu ayarla
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(
                this.camera.position.clone().sub(this.targetLookAt)
            );
            
            spherical.theta += this.mouseControl.yaw;
            spherical.phi += this.mouseControl.pitch;
            
            // Phi'yi sƒ±nƒ±rla (√ßok yukarƒ±/a≈üaƒüƒ± bakmasƒ±n)
            spherical.phi = MathUtils.clamp(spherical.phi, 0.1, Math.PI - 0.1);
            
            const newPosition = new THREE.Vector3();
            newPosition.setFromSpherical(spherical);
            newPosition.add(this.targetLookAt);
            
            this.camera.position.copy(newPosition);
            this.camera.lookAt(this.targetLookAt);
        }
    }
    
    /**
     * Kamera sarsƒ±ntƒ±sƒ±nƒ± g√ºncelle
     */
    updateShake(deltaTime) {
        if (this.shakeDuration > 0) {
            this.shakeTimer += deltaTime;
            
            if (this.shakeTimer < this.shakeDuration) {
                // Shake efekti uygula
                const shakeAmount = this.shakeIntensity * 
                    (1 - this.shakeTimer / this.shakeDuration); // Azalan
                
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                const shakeZ = (Math.random() - 0.5) * shakeAmount;
                
                this.camera.position.add(new THREE.Vector3(shakeX, shakeY, shakeZ));
            } else {
                // Shake bitti
                this.shakeDuration = 0;
                this.shakeTimer = 0;
                this.shakeIntensity = 0;
            }
        }
    }
    
    /**
     * Kamera sarsƒ±ntƒ±sƒ± ba≈ülat
     */
    shake(intensity = 0.1, duration = 0.3) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
        this.shakeTimer = 0;
    }
    
    /**
     * Belirli bir pozisyona yumu≈üak ge√ßi≈ü
     */
    smoothTransitionTo(position, lookAt, duration = 2.0) {
        // Gelecekte animasyon sistemi i√ßin
        // ≈ûimdilik direkt ayarla
        this.targetPosition.copy(position);
        this.targetLookAt.copy(lookAt);
    }
    
    /**
     * Kamera modunu ayarla
     */
    setCameraMode(mode) {
        if (Object.values(this.modes).includes(mode)) {
            this.currentMode = mode;
            
            // Mouse kontrol√ºn√º sƒ±fƒ±rla
            this.mouseControl.pitch = 0;
            this.mouseControl.yaw = 0;
            
            console.log(`üì∑ Kamera modu ayarlandƒ±: ${mode}`);
        }
    }
    
    /**
     * Kamera ayarlarƒ±nƒ± g√ºncelle
     */
    updateSettings(mode, settings) {
        if (this.settings[mode]) {
            Object.assign(this.settings[mode], settings);
        }
    }
    
    /**
     * Mevcut kamera modunu al
     */
    getCurrentMode() {
        return this.currentMode;
    }
    
    /**
     * Kamera pozisyonunu al
     */
    getPosition() {
        return this.camera.position.clone();
    }
    
    /**
     * Kamera baktƒ±ƒüƒ± y√∂n√º al
     */
    getLookDirection() {
        const direction = new THREE.Vector3();
        this.camera.getWorldDirection(direction);
        return direction;
    }
}
