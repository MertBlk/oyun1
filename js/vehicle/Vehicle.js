import * as THREE from 'three';
import { MathUtils } from '../utils/MathUtils.js';

/**
 * 3D Ara√ß sƒ±nƒ±fƒ± - temel geometrik ≈üekillerle ba≈ülangƒ±√ß
 */
export class Vehicle {
    constructor(scene) {
        this.scene = scene;
        
        // THREE.js Group - EKLE
        this.group = new THREE.Group();
        
        // Temel √∂zellikler
        this.position = new THREE.Vector3(0, 0, 0);
        this.rotation = new THREE.Euler(0, 0, 0); // THREE.Euler objesi olarak deƒüi≈ütir
        this.rotationY = 0; // Y ekseni rotasyonu i√ßin ayrƒ± sayƒ±
        this.currentSpeed = 0; // m/s cinsinden
        this.speed = 0; // km/h cinsinden (UI i√ßin)
        
        // Fizik property'leri - EKLE
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.acceleration = new THREE.Vector3(0, 0, 0);
        this.angularVelocity = 0;
        this.steering_angle = 0;
        this.max_steering_angle = Math.PI / 6; // 30 derece
        this.acceleration_force = 5000;
        this.brake_force = 3000;
        this.mass = 1000;
        // Fizik √∂zellikleri - BASƒ∞TLE≈ûTƒ∞Rƒ∞LMƒ∞≈û
        this.maxSpeed = 100; // km/h
        this.friction = 0.95; // S√ºrt√ºnme katsayƒ±sƒ±

        // Ara√ß boyutlarƒ±
        this.dimensions = {
            width: 1.8,
            height: 1.2,
            length: 4.0
        };
        
        // Ara√ß par√ßalarƒ±
        this.body = null;
        this.wheels = [];
        
        // Animasyon ve efektler
        this.isGrounded = true;
        this.engineSound = null; // Gelecekte ses sistemi i√ßin
        
        this.createVehicle();
        this.setupPhysics();
        
        console.log('üöó Ara√ß olu≈üturuldu');
    }
    
    /**
     * Aracƒ± olu≈ütur (temel geometrik ≈üekiller)
     */
    createVehicle() {
        this.createBody();
        this.createWheels();
        
        // Aracƒ± sahneye ekle
        this.scene.add(this.group);
        
        // Ba≈ülangƒ±√ß pozisyonu
        this.group.position.copy(this.position);
    }
    
    /**
     * Ara√ß g√∂vdesi olu≈ütur
     */
    createBody() {
        // Ana g√∂vde (dikd√∂rtgen)
        const bodyGeometry = new THREE.BoxGeometry(
            this.dimensions.width,
            this.dimensions.height,
            this.dimensions.length
        );
        
        const bodyMaterial = new THREE.MeshLambertMaterial({
            color: 0xff4444
        });
        
        this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        this.body.position.y = this.dimensions.height / 2 + 0.3; // Tekerleklerin √ºst√ºnde
        this.body.castShadow = true;
        this.body.receiveShadow = true;
        
        // Cam (√ºst kƒ±sƒ±m)
        const windowGeometry = new THREE.BoxGeometry(
            this.dimensions.width * 0.8,
            this.dimensions.height * 0.4,
            this.dimensions.length * 0.6
        );
        
        const windowMaterial = new THREE.MeshLambertMaterial({
            color: 0x4444ff,
            transparent: true,
            opacity: 0.6
        });
        
        const windows = new THREE.Mesh(windowGeometry, windowMaterial);
        windows.position.y = this.dimensions.height * 0.7;
        this.body.add(windows);
        
        this.group.add(this.body);
    }
    
    /**
     * Tekerlekleri olu≈ütur
     */
    createWheels() {
        const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
        const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
        
        // Tekerlek pozisyonlarƒ± (√∂n sol, √∂n saƒü, arka sol, arka saƒü)
        const wheelPositions = [
            { x: -this.dimensions.width/2 - 0.1, y: 0.3, z: this.dimensions.length/2 - 0.5 },  // √ñn sol
            { x: this.dimensions.width/2 + 0.1, y: 0.3, z: this.dimensions.length/2 - 0.5 },   // √ñn saƒü
            { x: -this.dimensions.width/2 - 0.1, y: 0.3, z: -this.dimensions.length/2 + 0.5 }, // Arka sol
            { x: this.dimensions.width/2 + 0.1, y: 0.3, z: -this.dimensions.length/2 + 0.5 }   // Arka saƒü
        ];
        
        wheelPositions.forEach((pos, index) => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.position.set(pos.x, pos.y, pos.z);
            wheel.rotation.z = Math.PI / 2; // Tekerlekleri yatay √ßevir
            wheel.castShadow = true;
            
            // Tekerlek animasyonu i√ßin referans
            wheel.userData = {
                isStearing: index < 2, // ƒ∞lk iki tekerlek (√∂n tekerlekler) direksiyon
                rotationSpeed: 0
            };
            
            this.wheels.push(wheel);
            this.group.add(wheel);
        });
    }
    
    /**
     * Fizik sistemini ayarla
     */
    setupPhysics() {
        // Ba≈ülangƒ±√ß deƒüerleri - √∂nceden tanƒ±mlanmƒ±≈ü vectorlarƒ± kullan
        this.velocity.set(0, 0, 0);
        this.acceleration.set(0, 0, 0);
        this.angularVelocity = 0;
    }
    
    /**
     * Aracƒ± g√ºncelle
     */
    update(deltaTime, inputState) {
        // Input'larƒ± al
        const throttle = inputState.forward ? 1 : (inputState.backward ? -0.6 : 0);
        const brake = inputState.handbrake ? 1 : 0;
        
        // STEERING - D√úZELTƒ∞LDƒ∞ - Y√ñN SORUNU √á√ñZ√úLD√ú
        let steering = 0;
        if (inputState.left) steering = 1;    // A tu≈üu = SOLA (pozitif rotasyon)
        if (inputState.right) steering = -1;  // D tu≈üu = SAƒûA (negatif rotasyon)
        
        // DEBUG - daha az spam
        if (throttle !== 0 && Date.now() - (this.lastDebugLog || 0) > 1000) { // 1 saniyede bir
            console.log('üöó Throttle aktif:', throttle, 'Input:', inputState);
            this.lastDebugLog = Date.now();
        }
        
        // BASƒ∞T Fƒ∞Zƒ∞K - kompleks fizik yerine
        if (Math.abs(throttle) > 0.1) {
            // ƒ∞leri/geri hareket
            const acceleration = throttle * 50; // Sabit ivme
            this.currentSpeed += acceleration * deltaTime;
            
            // Maksimum hƒ±zƒ± sƒ±nƒ±rla
            this.currentSpeed = MathUtils.clamp(this.currentSpeed, -30, 100);
        } else {
            // Doƒüal yava≈ülama
            this.currentSpeed *= 0.95;
        }
        
        // Direksiyon - Angular velocity de eklensin, D√úZELTƒ∞LDƒ∞
        if (Math.abs(steering) > 0.1 && Math.abs(this.currentSpeed) > 1) {
            const rotationChange = steering * 0.015 * (this.currentSpeed / 50); // 0.02'den 0.015'e d√º≈ü√ºr√ºld√º
            this.rotationY += rotationChange;
            
            // Angular velocity'yi daha yumu≈üak hesapla (kamera i√ßin)
            this.angularVelocity = MathUtils.lerp(this.angularVelocity, rotationChange / deltaTime, 0.3);
        } else {
            // Angular velocity'yi yumu≈üak sƒ±fƒ±rla
            this.angularVelocity *= 0.85; // 0.9'dan 0.85'e d√º≈ü√ºr√ºld√º - daha hƒ±zlƒ± sƒ±fƒ±rlama
        }
        
        // Pozisyonu g√ºncelle
        const moveDistance = this.currentSpeed * deltaTime;
        this.position.x += Math.sin(this.rotationY) * moveDistance;
        this.position.z += Math.cos(this.rotationY) * moveDistance;
        
        // THREE.Euler objesini g√ºncelle
        this.rotation.set(0, this.rotationY, 0);
        
        // Mesh'i g√ºncelle
        this.group.position.copy(this.position);
        this.group.rotation.copy(this.rotation);
        
        // Hƒ±z hesapla (km/h)
        this.speed = Math.abs(this.currentSpeed) * 3.6;
        
        // Debug - daha az spam
        if (Date.now() - (this.lastSpeedLog || 0) > 2000) { // 2 saniyede bir
            console.log('üöó Speed:', this.speed.toFixed(1), 'Position:', this.position.x.toFixed(1), this.position.z.toFixed(1));
            this.lastSpeedLog = Date.now();
        }
    }
    
    /**
     * Ara√ß pozisyonunu al
     */
    getPosition() {
        return this.position.clone();
    }
    
    /**
     * Ara√ß rotasyonunu al
     */
    getRotation() {
        return this.rotation.clone();
    }
    
    /**
     * Ara√ß hƒ±zƒ±nƒ± al (km/h)
     */
    getSpeed() {
        return this.speed || 0;
    }
    
    /**
     * Ara√ß mesh'ini al
     */
    getMesh() {
        return this.group;
    }
    
    /**
     * Aracƒ±n y√∂n√ºn√º al (radyan)
     */
    getDirection() {
        return this.rotationY;
    }
    
    /**
     * Aracƒ±n hƒ±zƒ±nƒ± m/s cinsinden al
     */
    getVelocity() {
        return this.currentSpeed;
    }
    
    /**
     * Ara√ß bilgilerini al (debug i√ßin)
     */
    getInfo() {
        return {
            position: this.position.clone(),
            rotation: this.rotationY,
            speed: this.speed,
            velocity: this.currentSpeed
        };
    }
    
    /**
     * Fizik hesaplamalarƒ±nƒ± yap
     */
    updatePhysics(deltaTime, throttle, steering, brake) {
        // Direksiyon a√ßƒ±sƒ±nƒ± g√ºncelle
        this.steering_angle = MathUtils.lerp(
            this.steering_angle,
            steering * this.max_steering_angle,
            deltaTime * 8
        );
        
        // Kuvvetleri hesapla - BU KISMI D√úZELTELƒ∞M
        const forces = new THREE.Vector3(0, 0, 0);
        
        // ƒ∞leri/geri kuvvet - DOƒûRUDAN UYGULA
        if (Math.abs(throttle) > 0.1) {
            // Aracƒ±n y√∂n√ºn√º dikkate alarak kuvvet uygula
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyEuler(this.rotation);
            
            const engineForce = throttle * this.acceleration_force;
            forces.add(forward.multiplyScalar(engineForce));
        }
        
        // Fren kuvveti
        if (brake > 0.1) {
            const brakeDirection = this.velocity.clone().normalize().multiplyScalar(-1);
            forces.add(brakeDirection.multiplyScalar(this.brake_force * brake));
        }
        
        // Hava direnci - azalt
        const airResistanceForce = this.velocity.clone()
            .multiplyScalar(-this.velocity.lengthSq() * 0.1); // 0.5'den 0.1'e d√º≈ü√ºr
        forces.add(airResistanceForce);
        
        // Yuvarlanma direnci - azalt
        const rollingResistanceForce = this.velocity.clone()
            .multiplyScalar(-10); // 50'den 10'a d√º≈ü√ºr
        forces.add(rollingResistanceForce);
        
        // Newton'un ikinci yasasƒ±: F = ma -> a = F/m
        this.acceleration.copy(forces).divideScalar(this.mass);
        
        // Hƒ±zƒ± g√ºncelle
        this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));
        
        // Maksimum hƒ±zƒ± sƒ±nƒ±rla
        if (this.velocity.length() > this.maxSpeed) {
            this.velocity.normalize().multiplyScalar(this.maxSpeed);
        }
        
        // A√ßƒ±sal hƒ±z (direksiyon) - BASITLE≈ûTIR
        if (this.velocity.length() > 0.1 && Math.abs(this.steering_angle) > 0.01) {
            this.angularVelocity = (this.steering_angle * this.velocity.length()) / this.dimensions.length;
        } else {
            this.angularVelocity *= 0.95;
        }
        
        // Pozisyonu g√ºncelle - BASITLE≈ûTIR
        this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        
        // Rotasyonu g√ºncelle
        this.rotation.y += this.angularVelocity * deltaTime;
        
        // Diren√ß kuvvetlerini uygula - AZALT
        this.velocity.multiplyScalar(0.99); // 0.98'den 0.99'a √ßƒ±kar
    }
    
    /**
     * 3D nesne transformunu g√ºncelle
     */
    updateTransform() {
        this.group.position.copy(this.position);
        this.group.rotation.copy(this.rotation);
    }
    
    /**
     * Tekerlek animasyonlarƒ±nƒ± g√ºncelle
     */
    updateWheelAnimations(deltaTime) {
        const wheelRotationSpeed = this.velocity.length() * 3; // Tekerlek d√∂n√º≈ü hƒ±zƒ±
        
        this.wheels.forEach((wheel, index) => {
            // Tekerlek d√∂n√º≈ü√º (ileri/geri hareket)
            wheel.rotation.x += wheelRotationSpeed * deltaTime;
            
            // √ñn tekerlekler i√ßin direksiyon
            if (wheel.userData.isStearing) {
                wheel.rotation.y = this.steering_angle;
            }
        });
    }
    
    /**
     * Aracƒ± sƒ±fƒ±rla (ba≈ülangƒ±√ß pozisyonuna d√∂n)
     */
    reset() {
        this.position.set(0, 0, 0);
        this.velocity.set(0, 0, 0);
        this.acceleration.set(0, 0, 0);
        this.rotation.set(0, 0, 0);
        this.angularVelocity = 0;
        this.steering_angle = 0;
        this.speed = 0;
        
        this.updateTransform();
        
        console.log('üîÑ Ara√ß sƒ±fƒ±rlandƒ±');
    }
    
    /**
     * Kaynaklarƒ± temizle
     */
    dispose() {
        // Geometry ve material'larƒ± temizle
        this.group.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
        
        // Sahneye nesneyi kaldƒ±r
        this.scene.remove(this.group);
        
        console.log('üóëÔ∏è Ara√ß kaynaklarƒ± temizlendi');
    }
}
